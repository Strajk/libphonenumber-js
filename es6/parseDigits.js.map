{"version":3,"sources":["../source/parseDigits.js"],"names":["DIGITS","parseDigit","character","parseDigits","string","result","split","digit"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMA,SACb;AACC,MAAK,GADN;AAEC,MAAK,GAFN;AAGC,MAAK,GAHN;AAIC,MAAK,GAJN;AAKC,MAAK,GALN;AAMC,MAAK,GANN;AAOC,MAAK,GAPN;AAQC,MAAK,GARN;AASC,MAAK,GATN;AAUC,MAAK,GAVN;AAWC,WAAU,GAXX,EAWgB;AACf,WAAU,GAZX,EAYgB;AACf,WAAU,GAbX,EAagB;AACf,WAAU,GAdX,EAcgB;AACf,WAAU,GAfX,EAegB;AACf,WAAU,GAhBX,EAgBgB;AACf,WAAU,GAjBX,EAiBgB;AACf,WAAU,GAlBX,EAkBgB;AACf,WAAU,GAnBX,EAmBgB;AACf,WAAU,GApBX,EAoBgB;AACf,WAAU,GArBX,EAqBgB;AACf,WAAU,GAtBX,EAsBgB;AACf,WAAU,GAvBX,EAuBgB;AACf,WAAU,GAxBX,EAwBgB;AACf,WAAU,GAzBX,EAyBgB;AACf,WAAU,GA1BX,EA0BgB;AACf,WAAU,GA3BX,EA2BgB;AACf,WAAU,GA5BX,EA4BgB;AACf,WAAU,GA7BX,EA6BgB;AACf,WAAU,GA9BX,EA8BgB;AACf,WAAU,GA/BX,EA+BgB;AACf,WAAU,GAhCX,EAgCgB;AACf,WAAU,GAjCX,EAiCgB;AACf,WAAU,GAlCX,EAkCgB;AACf,WAAU,GAnCX,EAmCgB;AACf,WAAU,GApCX,EAoCgB;AACf,WAAU,GArCX,EAqCgB;AACf,WAAU,GAtCX,EAsCgB;AACf,WAAU,GAvCX,EAuCgB;AACf,WAAU,GAxCX,CAwCgB;AAxChB,CADO;;AA4CP,OAAO,SAASC,UAAT,CAAoBC,SAApB,EACP;AACC,QAAOF,OAAOE,SAAP,CAAP;AACA;;AAED;;;;;;;;;;;;;AAaA,eAAe,SAASC,WAAT,CAAqBC,MAArB,EACf;AACC,KAAIC,SAAS,EAAb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAwBD,OAAOE,KAAP,CAAa,EAAb,CAAxB,kHACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,MADWJ,SACX;;AACC,MAAMK,QAAQN,WAAWC,SAAX,CAAd;AACA,MAAIK,KAAJ,EAAW;AACVF,aAAUE,KAAV;AACA;AACD;;AAED,QAAOF,MAAP;AACA","file":"parseDigits.js","sourcesContent":["// These mappings map a character (key) to a specific digit that should\n// replace it for normalization purposes. Non-European digits that\n// may be used in phone numbers are mapped to a European equivalent.\n//\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\n//\nexport const DIGITS =\n{\n\t'0': '0',\n\t'1': '1',\n\t'2': '2',\n\t'3': '3',\n\t'4': '4',\n\t'5': '5',\n\t'6': '6',\n\t'7': '7',\n\t'8': '8',\n\t'9': '9',\n\t'\\uFF10': '0', // Fullwidth digit 0\n\t'\\uFF11': '1', // Fullwidth digit 1\n\t'\\uFF12': '2', // Fullwidth digit 2\n\t'\\uFF13': '3', // Fullwidth digit 3\n\t'\\uFF14': '4', // Fullwidth digit 4\n\t'\\uFF15': '5', // Fullwidth digit 5\n\t'\\uFF16': '6', // Fullwidth digit 6\n\t'\\uFF17': '7', // Fullwidth digit 7\n\t'\\uFF18': '8', // Fullwidth digit 8\n\t'\\uFF19': '9', // Fullwidth digit 9\n\t'\\u0660': '0', // Arabic-indic digit 0\n\t'\\u0661': '1', // Arabic-indic digit 1\n\t'\\u0662': '2', // Arabic-indic digit 2\n\t'\\u0663': '3', // Arabic-indic digit 3\n\t'\\u0664': '4', // Arabic-indic digit 4\n\t'\\u0665': '5', // Arabic-indic digit 5\n\t'\\u0666': '6', // Arabic-indic digit 6\n\t'\\u0667': '7', // Arabic-indic digit 7\n\t'\\u0668': '8', // Arabic-indic digit 8\n\t'\\u0669': '9', // Arabic-indic digit 9\n\t'\\u06F0': '0', // Eastern-Arabic digit 0\n\t'\\u06F1': '1', // Eastern-Arabic digit 1\n\t'\\u06F2': '2', // Eastern-Arabic digit 2\n\t'\\u06F3': '3', // Eastern-Arabic digit 3\n\t'\\u06F4': '4', // Eastern-Arabic digit 4\n\t'\\u06F5': '5', // Eastern-Arabic digit 5\n\t'\\u06F6': '6', // Eastern-Arabic digit 6\n\t'\\u06F7': '7', // Eastern-Arabic digit 7\n\t'\\u06F8': '8', // Eastern-Arabic digit 8\n\t'\\u06F9': '9'  // Eastern-Arabic digit 9\n}\n\nexport function parseDigit(character)\n{\n\treturn DIGITS[character]\n}\n\n/**\n * Parses phone number digits from a string.\n * Drops all punctuation leaving only digits.\n * Also converts wide-ascii and arabic-indic numerals to conventional numerals.\n * E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\n * @param  {string} string\n * @return {string}\n * @example\n * ```js\n * parseDigits('8 (800) 555')\n * // Outputs '8800555'.\n * ```\n */\nexport default function parseDigits(string)\n{\n\tlet result = ''\n\n\t// Using `.split('')` here instead of normal `for ... of`\n\t// because the importing application doesn't neccessarily include an ES6 polyfill.\n\t// The `.split('')` approach discards \"exotic\" UTF-8 characters\n\t// (the ones consisting of four bytes) but digits\n\t// (including non-European ones) don't fall into that range\n\t// so such \"exotic\" characters would be discarded anyway.\n\tfor (const character of string.split(''))\n\t{\n\t\tconst digit = parseDigit(character)\n\t\tif (digit) {\n\t\t\tresult += digit\n\t\t}\n\t}\n\n\treturn result\n}"]}