{"version":3,"sources":["../source/format.js"],"names":["_formatNumber","parse","formatNumber","normalizeArguments","arguments","input","format","options","metadata","args","Array","prototype","slice","call","arg_1","arg_2","arg_3","arg_4","arg_5","defaultCountry","extended","Error","is_object","TypeError","_"],"mappings":";;;;AAAA,OAAOA,aAAP,MAA0B,WAA1B;AACA,OAAOC,KAAP,MAAkB,UAAlB;;AAEA,eAAe,SAASC,YAAT,GACf;AAAA,2BAQGC,mBAAmBC,SAAnB,CARH;AAAA,KAGEC,KAHF,uBAGEA,KAHF;AAAA,KAIEC,MAJF,uBAIEA,MAJF;AAAA,KAKEC,OALF,uBAKEA,OALF;AAAA,KAMEC,QANF,uBAMEA,QANF;;AAUC,QAAOR,cAAcK,KAAd,EAAqBC,MAArB,EAA6BC,OAA7B,EAAsCC,QAAtC,CAAP;AACA;;AAED;AACA,SAASL,kBAAT,CAA4BM,IAA5B,EACA;AAAA,6BAC6CC,MAAMC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BJ,IAA3B,CAD7C;AAAA;AAAA,KACQK,KADR;AAAA,KACeC,KADf;AAAA,KACsBC,KADtB;AAAA,KAC6BC,KAD7B;AAAA,KACoCC,KADpC;;AAGC,KAAIb,cAAJ;AACA,KAAIC,eAAJ;AACA,KAAIC,gBAAJ;AACA,KAAIC,iBAAJ;;AAEA;;AAEA;AACA;AACA,KAAI,OAAOM,KAAP,KAAiB,QAArB,EACA;AACC;AACA;AACA,MAAI,OAAOE,KAAP,KAAiB,QAArB,EACA;AACCV,YAASU,KAAT;;AAEA,OAAIE,KAAJ,EACA;AACCX,cAAWU,KAAX;AACAT,eAAWU,KAAX;AACA,IAJD,MAMA;AACCV,eAAWS,KAAX;AACA;;AAEDZ,WAAQJ,MAAMa,KAAN,EAAa,EAAEK,gBAAgBJ,KAAlB,EAAyBK,UAAU,IAAnC,EAAb,EAAwDZ,QAAxD,CAAR;AACA;AACD;AACA;AAjBA,OAmBA;AACC,QAAI,OAAOO,KAAP,KAAiB,QAArB,EACA;AACC,WAAM,IAAIM,KAAJ,CAAU,gEAAV,CAAN;AACA;;AAEDf,aAASS,KAAT;;AAEA,QAAIE,KAAJ,EACA;AACCV,eAAWS,KAAX;AACAR,gBAAWS,KAAX;AACA,KAJD,MAMA;AACCT,gBAAWQ,KAAX;AACA;;AAEDX,YAAQJ,MAAMa,KAAN,EAAa,EAAEM,UAAU,IAAZ,EAAb,EAAiCZ,QAAjC,CAAR;AACA;AACD;AACD;AACA;AA7CA,MA8CK,IAAIc,UAAUR,KAAV,CAAJ,EACL;AACCT,WAASS,KAAT;AACAR,YAASS,KAAT;;AAEA,OAAIE,KAAJ,EACA;AACCV,cAAWS,KAAX;AACAR,eAAWS,KAAX;AACA,IAJD,MAMA;AACCT,eAAWQ,KAAX;AACA;AACD,GAdI,MAeA,MAAM,IAAIO,SAAJ,CAAc,oFAAd,CAAN;;AAEL;AACA,KAAIjB,WAAW,eAAf,EAAgC;AAC/BA,WAAS,eAAT;AACA,EAFD,MAEO,IAAIA,WAAW,UAAf,EAA2B;AACjCA,WAAS,UAAT;AACA;;AAED,QAAO;AACND,cADM;AAENC,gBAFM;AAGNC,kBAHM;AAINC;AAJM,EAAP;AAMA;;AAED;AACA;AACA;AACA,IAAMc,YAAY,SAAZA,SAAY;AAAA,QAAK,QAAOE,CAAP,yCAAOA,CAAP,OAAa,QAAlB;AAAA,CAAlB","file":"format.js","sourcesContent":["import _formatNumber from './format_'\nimport parse from './parse_'\n\nexport default function formatNumber()\n{\n\tconst\n\t{\n\t\tinput,\n\t\tformat,\n\t\toptions,\n\t\tmetadata\n\t}\n\t= normalizeArguments(arguments)\n\n\treturn _formatNumber(input, format, options, metadata)\n}\n\n// Sort out arguments\nfunction normalizeArguments(args)\n{\n\tconst [arg_1, arg_2, arg_3, arg_4, arg_5] = Array.prototype.slice.call(args)\n\n\tlet input\n\tlet format\n\tlet options\n\tlet metadata\n\n\t// Sort out arguments.\n\n\t// If the phone number is passed as a string.\n\t// `format('8005553535', ...)`.\n\tif (typeof arg_1 === 'string')\n\t{\n\t\t// If country code is supplied.\n\t\t// `format('8005553535', 'RU', 'NATIONAL', [options], metadata)`.\n\t\tif (typeof arg_3 === 'string')\n\t\t{\n\t\t\tformat = arg_3\n\n\t\t\tif (arg_5)\n\t\t\t{\n\t\t\t\toptions  = arg_4\n\t\t\t\tmetadata = arg_5\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmetadata = arg_4\n\t\t\t}\n\n\t\t\tinput = parse(arg_1, { defaultCountry: arg_2, extended: true }, metadata)\n\t\t}\n\t\t// Just an international phone number is supplied\n\t\t// `format('+78005553535', 'NATIONAL', [options], metadata)`.\n\t\telse\n\t\t{\n\t\t\tif (typeof arg_2 !== 'string')\n\t\t\t{\n\t\t\t\tthrow new Error('`format` argument not passed to `formatNumber(number, format)`')\n\t\t\t}\n\n\t\t\tformat = arg_2\n\n\t\t\tif (arg_4)\n\t\t\t{\n\t\t\t\toptions  = arg_3\n\t\t\t\tmetadata = arg_4\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmetadata = arg_3\n\t\t\t}\n\n\t\t\tinput = parse(arg_1, { extended: true }, metadata)\n\t\t}\n\t}\n\t// If the phone number is passed as a parsed number object.\n\t// `format({ phone: '8005553535', country: 'RU' }, 'NATIONAL', [options], metadata)`.\n\telse if (is_object(arg_1))\n\t{\n\t\tinput  = arg_1\n\t\tformat = arg_2\n\n\t\tif (arg_4)\n\t\t{\n\t\t\toptions  = arg_3\n\t\t\tmetadata = arg_4\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmetadata = arg_3\n\t\t}\n\t}\n\telse throw new TypeError('A phone number must either be a string or an object of shape { phone, [country] }.')\n\n\t// Legacy lowercase formats.\n\tif (format === 'International') {\n\t\tformat = 'INTERNATIONAL'\n\t} else if (format === 'National') {\n\t\tformat = 'NATIONAL'\n\t}\n\n\treturn {\n\t\tinput,\n\t\tformat,\n\t\toptions,\n\t\tmetadata\n\t}\n}\n\n// Babel transforms `typeof` into some \"branches\"\n// so istanbul will show this as \"branch not covered\".\n/* istanbul ignore next */\nconst is_object = _ => typeof _ === 'object'"]}