{"version":3,"sources":["../source/metadata.js"],"names":["compare","V2","V3","DEFAULT_EXT_PREFIX","Metadata","metadata","validateMetadata","v1","version","v2","undefined","v3","country","countries","_country","country_metadata","hasCountry","Error","countryCallingCodes","countryCallingCode","formats","_getFormats","getDefaultCountryMetadataForRegion","map","Format","_","_getNationalPrefixFormattingRule","nationalPrefix","_getNationalPrefixIsOptionalWhenFormatting","types","length","type","hasTypes","getType","Type","country_phone_code_to_countries","country_calling_codes","country_calling_code","format","_format","nationalPrefixFormattingRule","nationalPrefixIsOptionalWhenFormatting","usesNationalPrefix","test","replace","possibleLengths","is_object","Object","keys","join","type_of","getExtPrefix","ext","getCountryCallingCode","isSupportedCountry"],"mappings":"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","file":"metadata.js","sourcesContent":["import compare from 'semver-compare'\n\n// Added \"possibleLengths\" and renamed\n// \"country_phone_code_to_countries\" to \"country_calling_codes\".\nconst V2 = '1.0.18'\n\n// Added \"idd_prefix\" and \"default_idd_prefix\".\nconst V3 = '1.2.0'\n\nconst DEFAULT_EXT_PREFIX = ' ext. '\n\nexport default class Metadata\n{\n\tconstructor(metadata)\n\t{\n\t\tvalidateMetadata(metadata)\n\n\t\tthis.metadata = metadata\n\n\t\tthis.v1 = !metadata.version\n\t\tthis.v2 = metadata.version !== undefined && compare(metadata.version, V3) === -1\n\t\tthis.v3 = metadata.version !== undefined // && compare(metadata.version, V4) === -1\n\t}\n\n\thasCountry(country)\n\t{\n\t\treturn this.metadata.countries[country] !== undefined\n\t}\n\n\tcountry(country)\n\t{\n\t\tif (!country)\n\t\t{\n\t\t\tthis._country = undefined\n\t\t\tthis.country_metadata = undefined\n\t\t\treturn this\n\t\t}\n\n\t\tif (!this.hasCountry(country))\n\t\t{\n\t\t\tthrow new Error(`Unknown country: ${country}`)\n\t\t}\n\n\t\tthis._country = country\n\t\tthis.country_metadata = this.metadata.countries[country]\n\t\treturn this\n\t}\n\n\tgetDefaultCountryMetadataForRegion()\n\t{\n\t\treturn this.metadata.countries[this.countryCallingCodes()[this.countryCallingCode()][0]]\n\t}\n\n\tcountryCallingCode()\n\t{\n\t\treturn this.country_metadata[0]\n\t}\n\n\tIDDPrefix()\n\t{\n\t\tif (this.v1 || this.v2) return\n\t\treturn this.country_metadata[1]\n\t}\n\n\tdefaultIDDPrefix()\n\t{\n\t\tif (this.v1 || this.v2) return\n\t\treturn this.country_metadata[12]\n\t}\n\n\tnationalNumberPattern()\n\t{\n\t\tif (this.v1 || this.v2) return this.country_metadata[1]\n\t\treturn this.country_metadata[2]\n\t}\n\n\tpossibleLengths()\n\t{\n\t\tif (this.v1) return\n\t\treturn this.country_metadata[this.v2 ? 2 : 3]\n\t}\n\n\t_getFormats(country_metadata)\n\t{\n\t\treturn country_metadata[this.v1 ? 2 : this.v2 ? 3 : 4]\n\t}\n\n\t// For countries of the same region (e.g. NANPA)\n\t// formats are all stored in the \"main\" country for that region.\n\t// E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\n\tformats()\n\t{\n\t\tconst formats = this._getFormats(this.country_metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || []\n\t\treturn formats.map(_ => new Format(_, this))\n\t}\n\n\tnationalPrefix()\n\t{\n\t\treturn this.country_metadata[this.v1 ? 3 : this.v2 ? 4 : 5]\n\t}\n\n\t_getNationalPrefixFormattingRule(country_metadata)\n\t{\n\t\treturn country_metadata[this.v1 ? 4 : this.v2 ? 5 : 6]\n\t}\n\n\t// For countries of the same region (e.g. NANPA)\n\t// national prefix formatting rule is stored in the \"main\" country for that region.\n\t// E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\n\tnationalPrefixFormattingRule()\n\t{\n\t\treturn this._getNationalPrefixFormattingRule(this.country_metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion())\n\t}\n\n\tnationalPrefixForParsing()\n\t{\n\t\t// If `national_prefix_for_parsing` is not set explicitly,\n\t\t// then infer it from `national_prefix` (if any)\n\t\treturn this.country_metadata[this.v1 ? 5 : this.v2 ? 6 : 7] || this.nationalPrefix()\n\t}\n\n\tnationalPrefixTransformRule()\n\t{\n\t\treturn this.country_metadata[this.v1 ? 6 : this.v2 ? 7 : 8]\n\t}\n\n\t_getNationalPrefixIsOptionalWhenFormatting()\n\t{\n\t\treturn !!this.country_metadata[this.v1 ? 7 : this.v2 ? 8 : 9]\n\t}\n\n\t// For countries of the same region (e.g. NANPA)\n\t// \"national prefix is optional when parsing\" flag is\n\t// stored in the \"main\" country for that region.\n\t// E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\n\tnationalPrefixIsOptionalWhenFormatting()\n\t{\n\t\treturn this._getNationalPrefixIsOptionalWhenFormatting(this.country_metadata) ||\n\t\t\tthis._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion())\n\t}\n\n\tleadingDigits()\n\t{\n\t\treturn this.country_metadata[this.v1 ? 8 : this.v2 ? 9 : 10]\n\t}\n\n\ttypes()\n\t{\n\t\treturn this.country_metadata[this.v1 ? 9 : this.v2 ? 10 : 11]\n\t}\n\n\thasTypes()\n\t{\n\t\t// Versions 1.2.0 - 1.2.4: can be `[]`.\n\t\t/* istanbul ignore next */\n\t\tif (this.types() && this.types().length === 0) {\n\t\t\treturn false\n\t\t}\n\t\t// Versions <= 1.2.4: can be `undefined`.\n\t\t// Version >= 1.2.5: can be `0`.\n\t\treturn !!this.types()\n\t}\n\n\ttype(type)\n\t{\n\t\tif (this.hasTypes() && getType(this.types(), type))\n\t\t{\n\t\t\treturn new Type(getType(this.types(), type), this)\n\t\t}\n\t}\n\n\text()\n\t{\n\t\tif (this.v1 || this.v2) return DEFAULT_EXT_PREFIX\n\t\treturn this.country_metadata[13] || DEFAULT_EXT_PREFIX\n\t}\n\n\tcountryCallingCodes()\n\t{\n\t\tif (this.v1) return this.metadata.country_phone_code_to_countries\n\t\treturn this.metadata.country_calling_codes\n\t}\n\n\t// Formatting information for regions which share\n\t// a country calling code is contained by only one region\n\t// for performance reasons. For example, for NANPA region\n\t// (\"North American Numbering Plan Administration\",\n\t//  which includes USA, Canada, Cayman Islands, Bahamas, etc)\n\t// it will be contained in the metadata for `US`.\n\t//\n\t// `country_calling_code` is always valid.\n\t// But the actual country may not necessarily be part of the metadata.\n\t//\n\tchooseCountryByCountryCallingCode(country_calling_code)\n\t{\n\t\tconst country = this.countryCallingCodes()[country_calling_code][0]\n\n\t\t// Do not want to test this case.\n\t\t// (custom metadata, not all countries).\n\t\t/* istanbul ignore else */\n\t\tif (this.hasCountry(country))\n\t\t{\n\t\t\tthis.country(country)\n\t\t}\n\t}\n\n\tselectedCountry()\n\t{\n\t\treturn this._country\n\t}\n}\n\nclass Format\n{\n\tconstructor(format, metadata)\n\t{\n\t\tthis._format = format\n\t\tthis.metadata = metadata\n\t}\n\n\tpattern()\n\t{\n\t\treturn this._format[0]\n\t}\n\n\tformat()\n\t{\n\t\treturn this._format[1]\n\t}\n\n\tleadingDigitsPatterns()\n\t{\n\t\treturn this._format[2] || []\n\t}\n\n\tnationalPrefixFormattingRule()\n\t{\n\t\treturn this._format[3] || this.metadata.nationalPrefixFormattingRule()\n\t}\n\n\tnationalPrefixIsOptionalWhenFormatting()\n\t{\n\t\treturn !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormatting()\n\t}\n\n\tnationalPrefixIsMandatoryWhenFormatting()\n\t{\n\t\t// National prefix is omitted if there's no national prefix formatting rule\n\t\t// set for this country, or when the national prefix formatting rule\n\t\t// contains no national prefix itself, or when this rule is set but\n\t\t// national prefix is optional for this phone number format\n\t\t// (and it is not enforced explicitly)\n\t\treturn this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormatting()\n\t}\n\n\t// Checks whether national prefix formatting rule contains national prefix.\n\tusesNationalPrefix()\n\t{\n\t\treturn this.nationalPrefixFormattingRule() &&\n\t\t\t// Check that national prefix formatting rule is not a dummy one.\n\t\t\tthis.nationalPrefixFormattingRule() !== '$1' &&\n\t\t\t// Check that national prefix formatting rule actually has national prefix digit(s).\n\t\t\t/\\d/.test(this.nationalPrefixFormattingRule().replace('$1', ''))\n\t}\n\n\tinternationalFormat()\n\t{\n\t\treturn this._format[5] || this.format()\n\t}\n}\n\nclass Type\n{\n\tconstructor(type, metadata)\n\t{\n\t\tthis.type = type\n\t\tthis.metadata = metadata\n\t}\n\n\tpattern()\n\t{\n\t\tif (this.metadata.v1) return this.type\n\t\treturn this.type[0]\n\t}\n\n\tpossibleLengths()\n\t{\n\t\tif (this.metadata.v1) return\n\t\treturn this.type[1] || this.metadata.possibleLengths()\n\t}\n}\n\nfunction getType(types, type)\n{\n\tswitch (type)\n\t{\n\t\tcase 'FIXED_LINE':\n\t\t\treturn types[0]\n\t\tcase 'MOBILE':\n\t\t\treturn types[1]\n\t\tcase 'TOLL_FREE':\n\t\t\treturn types[2]\n\t\tcase 'PREMIUM_RATE':\n\t\t\treturn types[3]\n\t\tcase 'PERSONAL_NUMBER':\n\t\t\treturn types[4]\n\t\tcase 'VOICEMAIL':\n\t\t\treturn types[5]\n\t\tcase 'UAN':\n\t\t\treturn types[6]\n\t\tcase 'PAGER':\n\t\t\treturn types[7]\n\t\tcase 'VOIP':\n\t\t\treturn types[8]\n\t\tcase 'SHARED_COST':\n\t\t\treturn types[9]\n\t}\n}\n\nexport function validateMetadata(metadata)\n{\n\tif (!metadata)\n\t{\n\t\tthrow new Error('[libphonenumber-js] `metadata` argument not passed. Check your arguments.')\n\t}\n\n\t// `country_phone_code_to_countries` was renamed to\n\t// `country_calling_codes` in `1.0.18`.\n\tif\n\t(\n\t\t!is_object(metadata) ||\n\t\t!is_object(metadata.countries) ||\n\t\t(!is_object(metadata.country_calling_codes) && !is_object(metadata.country_phone_code_to_countries))\n\t)\n\t{\n\t\tthrow new Error(`[libphonenumber-js] \\`metadata\\` argument was passed but it's not a valid metadata. Must be an object having \\`.countries\\` and \\`.country_calling_codes\\` child object properties. Got ${is_object(metadata) ? 'an object of shape: { ' + Object.keys(metadata).join(', ') + ' }' : 'a ' + type_of(metadata) + ': ' + metadata}.`)\n\t}\n}\n\n// Babel transforms `typeof` into some \"branches\"\n// so istanbul will show this as \"branch not covered\".\n/* istanbul ignore next */\nconst is_object = _ => typeof _ === 'object'\n\n// Babel transforms `typeof` into some \"branches\"\n// so istanbul will show this as \"branch not covered\".\n/* istanbul ignore next */\nconst type_of = _ => typeof _\n\n/**\n * Returns extension prefix for a country.\n * @param  {string} country\n * @param  {object} metadata\n * @return {string?}\n * @example\n * // Returns \" ext. \"\n * getExtPrefix(\"US\")\n */\nexport function getExtPrefix(country, metadata)\n{\n\tmetadata = new Metadata(metadata)\n\tif (metadata.hasCountry(country)) {\n\t\treturn metadata.country(country).ext()\n\t}\n\treturn DEFAULT_EXT_PREFIX\n}\n\n/**\n * Returns \"country calling code\" for a country.\n * Throws an error if the country doesn't exist or isn't supported by this library.\n * @param  {string} country\n * @param  {object} metadata\n * @return {string}\n * @example\n * // Returns \"44\"\n * getCountryCallingCode(\"GB\")\n */\nexport function getCountryCallingCode(country, metadata)\n{\n\tmetadata = new Metadata(metadata)\n\tif (metadata.hasCountry(country)) {\n\t\treturn metadata.country(country).countryCallingCode()\n\t}\n\tthrow new Error(`Unknown country: ${country}`)\n}\n\nexport function isSupportedCountry(country, metadata)\n{\n\t// metadata = new Metadata(metadata)\n\t// return metadata.hasCountry(country)\n\treturn metadata.countries[country] !== undefined\n}"]}