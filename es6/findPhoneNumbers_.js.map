{"version":3,"sources":["../source/findPhoneNumbers_.js"],"names":["PLUS_CHARS","VALID_PUNCTUATION","VALID_DIGITS","WHITESPACE","EXTN_PATTERNS_FOR_PARSING","parse","parsePreCandidate","isValidPreCandidate","isValidCandidate","VALID_PHONE_NUMBER","WHITESPACE_IN_THE_BEGINNING_PATTERN","RegExp","PUNCTUATION_IN_THE_END_PATTERN","VALID_PRECEDING_CHARACTER_PATTERN","findPhoneNumbers","text","options","metadata","undefined","search","PhoneNumberSearch","phones","hasNext","push","next","searchPhoneNumbers","Symbol","iterator","done","value","state","regexp","matches","exec","number","startsAt","index","replace","length","result","parseCandidate","find","extended","phone","endsAt","last_match","Error"],"mappings":";;;;;;AAAA;AACA;;AAEA,SACCA,UADD,EAECC,iBAFD,EAGCC,YAHD,EAICC,UAJD,QAKO,aALP;;AAOA,SAASC,yBAAT,QAA0C,aAA1C;;AAEA,OAAOC,KAAP,MAAkB,UAAlB;;AAEA,OAAOC,iBAAP,MAA8B,iCAA9B;AACA,OAAOC,mBAAP,MAAgC,mCAAhC;AACA,OAAOC,gBAAP,MAA6B,gCAA7B;;AAEA;AACA,IAAMC,qBACL,MAAMT,UAAN,GAAmB,QAAnB,GACA,KADA,GAEC,GAFD,GAEOC,iBAFP,GAE2B,IAF3B,GAGC,GAHD,GAGOC,YAHP,GAGsB,GAHtB,GAIA,OAJA,GAKA,GALA,GAMCD,iBAND,GAOCC,YAPD,GAQA,IATD;;AAWA,IAAMQ,sCAAsC,IAAIC,MAAJ,CAAW,OAAOR,UAAP,GAAoB,IAA/B,CAA5C;AACA,IAAMS,iCAAiC,IAAID,MAAJ,CAAW,MAAMV,iBAAN,GAA0B,KAArC,CAAvC;;AAEA;AACA;AACA;;AAEA,IAAMY,oCAAoC,cAA1C;;AAEA,eAAe,SAASC,gBAAT,CAA0BC,IAA1B,EAAgCC,OAAhC,EAAyCC,QAAzC,EACf;AACC;AACA,KAAID,YAAYE,SAAhB,EAA2B;AAC1BF,YAAU,EAAV;AACA;;AAED,KAAMG,SAAS,IAAIC,iBAAJ,CAAsBL,IAAtB,EAA4BC,OAA5B,EAAqCC,QAArC,CAAf;AACA,KAAMI,SAAS,EAAf;AACA,QAAOF,OAAOG,OAAP,EAAP,EAAyB;AACxBD,SAAOE,IAAP,CAAYJ,OAAOK,IAAP,EAAZ;AACA;AACD,QAAOH,MAAP;AACA;;AAED;;;AAGA,OAAO,SAASI,kBAAT,CAA4BV,IAA5B,EAAkCC,OAAlC,EAA2CC,QAA3C,EACP;AACC;AACA,KAAID,YAAYE,SAAhB,EAA2B;AAC1BF,YAAU,EAAV;AACA;;AAED,KAAMG,SAAS,IAAIC,iBAAJ,CAAsBL,IAAtB,EAA4BC,OAA5B,EAAqCC,QAArC,CAAf;;AAEA,4BACES,OAAOC,QADT,cACqB;AACnB,SAAO;AACHH,SAAM,gBAAM;AACX,QAAIL,OAAOG,OAAP,EAAJ,EAAsB;AACxB,YAAO;AACNM,YAAM,KADA;AAENC,aAAOV,OAAOK,IAAP;AAFD,MAAP;AAIA;AACD,WAAO;AACNI,WAAM;AADA,KAAP;AAGG;AAXE,GAAP;AAaA,EAfF;AAiBA;;AAED;;;;;AAKA,WAAaR,iBAAb;AAKC,4BAAYL,IAAZ,EACA;AAAA,MADkBC,OAClB,uEAD4B,EAC5B;AAAA,MADgCC,QAChC;;AAAA;;AAAA,OAHAa,KAGA,GAHQ,WAGR;;AACC,OAAKf,IAAL,GAAYA,IAAZ;AACA,OAAKC,OAAL,GAAeA,OAAf;AACA,OAAKC,QAAL,GAAgBA,QAAhB;;AAEA,OAAKc,MAAL,GAAc,IAAIpB,MAAJ,CAEbF;AACA;AACA,OAFA,GAEQL,yBAFR,GAEoC,IAJvB,EAKb,IALa,CAAd;;AAQA;AACA;AAlBD;;;AAFD;AAAA;AAAA,yBAuBC;AACC,OAAM4B,UAAU,KAAKD,MAAL,CAAYE,IAAZ,CAAiB,KAAKlB,IAAtB,CAAhB;;AAEA,OAAI,CAACiB,OAAL,EAAc;AACb;AACA;;AAED,OAAIE,SAAWF,QAAQ,CAAR,CAAf;AACA,OAAIG,WAAWH,QAAQI,KAAvB;;AAEAF,YAASA,OAAOG,OAAP,CAAe3B,mCAAf,EAAoD,EAApD,CAAT;AACAyB,eAAYH,QAAQ,CAAR,EAAWM,MAAX,GAAoBJ,OAAOI,MAAvC;AACA;AACA;AACA;AACAJ,YAASA,OAAOG,OAAP,CAAezB,8BAAf,EAA+C,EAA/C,CAAT;;AAEAsB,YAAS5B,kBAAkB4B,MAAlB,CAAT;;AAEA,OAAMK,SAAS,KAAKC,cAAL,CAAoBN,MAApB,EAA4BC,QAA5B,CAAf;;AAEA,OAAII,MAAJ,EAAY;AACX,WAAOA,MAAP;AACA;;AAED;AACA;AACA,UAAO,KAAKE,IAAL,EAAP;AACA;AAnDF;AAAA;AAAA,iCAqDgBP,MArDhB,EAqDwBC,QArDxB,EAsDC;AACC,OAAI,CAAC5B,oBAAoB2B,MAApB,EAA4BC,QAA5B,EAAsC,KAAKpB,IAA3C,CAAL,EAAuD;AACtD;AACA;;AAED;AACA;AACA;AACA;AACA,OAAI,CAACP,iBAAiB0B,MAAjB,EAAyBC,QAAzB,EAAmC,KAAKpB,IAAxC,EAA8C,KAAKC,OAAL,CAAa0B,QAAb,GAAwB,UAAxB,GAAqC,OAAnF,CAAL,EACA;AACC;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAMH,SAASlC,MAAM6B,MAAN,EAAc,KAAKlB,OAAnB,EAA4B,KAAKC,QAAjC,CAAf;;AAEA,OAAI,CAACsB,OAAOI,KAAZ,EAAmB;AAClB;AACA;;AAEDJ,UAAOJ,QAAP,GAAkBA,QAAlB;AACAI,UAAOK,MAAP,GAAkBT,WAAWD,OAAOI,MAApC;;AAEA,UAAOC,MAAP;AACA;AA1FF;AAAA;AAAA,4BA6FC;AACC,OAAI,KAAKT,KAAL,KAAe,WAAnB,EACA;AACC,SAAKe,UAAL,GAAkB,KAAKJ,IAAL,EAAlB;;AAEA,QAAI,KAAKI,UAAT,EACA;AACC,UAAKf,KAAL,GAAa,OAAb;AACA,KAHD,MAKA;AACC,UAAKA,KAAL,GAAa,MAAb;AACA;AACD;;AAED,UAAO,KAAKA,KAAL,KAAe,OAAtB;AACA;AA7GF;AAAA;AAAA,yBAgHC;AACC;AACA,OAAI,CAAC,KAAKR,OAAL,EAAL,EACA;AACC,UAAM,IAAIwB,KAAJ,CAAU,iBAAV,CAAN;AACA;;AAED;AACA,OAAMP,SAAS,KAAKM,UAApB;AACA,QAAKA,UAAL,GAAkB,IAAlB;AACA,QAAKf,KAAL,GAAa,WAAb;AACA,UAAOS,MAAP;AACA;AA5HF;;AAAA;AAAA","file":"findPhoneNumbers_.js","sourcesContent":["// This is a legacy function.\n// Use `findNumbers()` instead.\n\nimport {\n\tPLUS_CHARS,\n\tVALID_PUNCTUATION,\n\tVALID_DIGITS,\n\tWHITESPACE\n} from './constants'\n\nimport { EXTN_PATTERNS_FOR_PARSING } from './extension'\n\nimport parse from './parse_'\n\nimport parsePreCandidate from './findNumbers/parsePreCandidate'\nimport isValidPreCandidate from './findNumbers/isValidPreCandidate'\nimport isValidCandidate from './findNumbers/isValidCandidate'\n\n// Copy-pasted from `./parse.js`.\nconst VALID_PHONE_NUMBER =\n\t'[' + PLUS_CHARS + ']{0,1}' +\n\t'(?:' +\n\t\t'[' + VALID_PUNCTUATION + ']*' +\n\t\t'[' + VALID_DIGITS + ']' +\n\t'){3,}' +\n\t'[' +\n\t\tVALID_PUNCTUATION +\n\t\tVALID_DIGITS +\n\t']*'\n\nconst WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + WHITESPACE + ']+')\nconst PUNCTUATION_IN_THE_END_PATTERN = new RegExp('[' + VALID_PUNCTUATION + ']+$')\n\n// // Regular expression for getting opening brackets for a valid number\n// // found using `PHONE_NUMBER_START_PATTERN` for prepending those brackets to the number.\n// const BEFORE_NUMBER_DIGITS_PUNCTUATION = new RegExp('[' + OPENING_BRACKETS + ']+' + '[' + WHITESPACE + ']*' + '$')\n\nconst VALID_PRECEDING_CHARACTER_PATTERN = /[^a-zA-Z0-9]/\n\nexport default function findPhoneNumbers(text, options, metadata)\n{\n\t/* istanbul ignore if */\n\tif (options === undefined) {\n\t\toptions = {}\n\t}\n\n\tconst search = new PhoneNumberSearch(text, options, metadata)\n\tconst phones = []\n\twhile (search.hasNext()) {\n\t\tphones.push(search.next())\n\t}\n\treturn phones\n}\n\n/**\n * @return ES6 `for ... of` iterator.\n */\nexport function searchPhoneNumbers(text, options, metadata)\n{\n\t/* istanbul ignore if */\n\tif (options === undefined) {\n\t\toptions = {}\n\t}\n\n\tconst search = new PhoneNumberSearch(text, options, metadata)\n\n\treturn  {\n\t\t[Symbol.iterator]() {\n\t\t\treturn {\n\t    \t\tnext: () => {\n\t    \t\t\tif (search.hasNext()) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t\tvalue: search.next()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: true\n\t\t\t\t\t}\n\t    \t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Extracts a parseable phone number including any opening brackets, etc.\n * @param  {string} text - Input.\n * @return {object} `{ ?number, ?startsAt, ?endsAt }`.\n */\nexport class PhoneNumberSearch\n{\n\t// Iteration tristate.\n\tstate = 'NOT_READY'\n\n\tconstructor(text, options = {}, metadata)\n\t{\n\t\tthis.text = text\n\t\tthis.options = options\n\t\tthis.metadata = metadata\n\n\t\tthis.regexp = new RegExp\n\t\t(\n\t\t\tVALID_PHONE_NUMBER +\n\t\t\t// Phone number extensions\n\t\t\t'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?',\n\t\t\t'ig'\n\t\t)\n\n\t\t// this.searching_from = 0\n\t}\n\n\tfind()\n\t{\n\t\tconst matches = this.regexp.exec(this.text)\n\n\t\tif (!matches) {\n\t\t\treturn\n\t\t}\n\n\t\tlet number   = matches[0]\n\t\tlet startsAt = matches.index\n\n\t\tnumber = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '')\n\t\tstartsAt += matches[0].length - number.length\n\t\t// Fixes not parsing numbers with whitespace in the end.\n\t\t// Also fixes not parsing numbers with opening parentheses in the end.\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/252\n\t\tnumber = number.replace(PUNCTUATION_IN_THE_END_PATTERN, '')\n\n\t\tnumber = parsePreCandidate(number)\n\n\t\tconst result = this.parseCandidate(number, startsAt)\n\n\t\tif (result) {\n\t\t\treturn result\n\t\t}\n\n\t\t// Tail recursion.\n\t\t// Try the next one if this one is not a valid phone number.\n\t\treturn this.find()\n\t}\n\n\tparseCandidate(number, startsAt)\n\t{\n\t\tif (!isValidPreCandidate(number, startsAt, this.text)) {\n\t\t\treturn\n\t\t}\n\n\t\t// Don't parse phone numbers which are non-phone numbers\n\t\t// due to being part of something else (e.g. a UUID).\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/213\n\t\t// Copy-pasted from Google's `PhoneNumberMatcher.js` (`.parseAndValidate()`).\n\t\tif (!isValidCandidate(number, startsAt, this.text, this.options.extended ? 'POSSIBLE' : 'VALID'))\n\t\t{\n\t\t\treturn\n\t\t}\n\n\t\t// // Prepend any opening brackets left behind by the\n\t\t// // `PHONE_NUMBER_START_PATTERN` regexp.\n\t\t// const text_before_number = text.slice(this.searching_from, startsAt)\n\t\t// const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)\n\t\t// if (full_number_starts_at >= 0)\n\t\t// {\n\t\t// \tnumber   = text_before_number.slice(full_number_starts_at) + number\n\t\t// \tstartsAt = full_number_starts_at\n\t\t// }\n\t\t//\n\t\t// this.searching_from = matches.lastIndex\n\n\t\tconst result = parse(number, this.options, this.metadata)\n\n\t\tif (!result.phone) {\n\t\t\treturn\n\t\t}\n\n\t\tresult.startsAt = startsAt\n\t\tresult.endsAt   = startsAt + number.length\n\n\t\treturn result\n\t}\n\n\thasNext()\n\t{\n\t\tif (this.state === 'NOT_READY')\n\t\t{\n\t\t\tthis.last_match = this.find()\n\n\t\t\tif (this.last_match)\n\t\t\t{\n\t\t\t\tthis.state = 'READY'\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.state = 'DONE'\n\t\t\t}\n\t\t}\n\n\t\treturn this.state === 'READY'\n\t}\n\n\tnext()\n\t{\n\t\t// Check the state and find the next match as a side-effect if necessary.\n\t\tif (!this.hasNext())\n\t\t{\n\t\t\tthrow new Error('No next element')\n\t\t}\n\n\t\t// Don't retain that memory any longer than necessary.\n\t\tconst result = this.last_match\n\t\tthis.last_match = null\n\t\tthis.state = 'NOT_READY'\n\t\treturn result\n\t}\n}"]}