{"version":3,"sources":["../source/parse_.js"],"names":["parse","extract_formatted_phone_number","strip_national_prefix_and_carrier_code","find_country_code","extractCountryCallingCode","MAX_INPUT_STRING_LENGTH","PHONE_NUMBER_START_PATTERN","RegExp","PLUS_CHARS","VALID_DIGITS","AFTER_PHONE_NUMBER_END_PATTERN","text","options","metadata","Metadata","defaultCountry","hasCountry","v2","ParseError","Error","parse_input","formatted_phone_number","number","ext","parse_phone_number","country","nationalNumber","national_number","countryCallingCode","carrierCode","selectedCountry","length","MIN_LENGTH_FOR_NSN","MAX_LENGTH_FOR_NSN","phoneNumber","PhoneNumber","valid","nationalNumberPattern","extended","result","possible","possibleLengths","undefined","phone","starts_at","search","slice","replace","nationalPrefixForParsing","national_prefix_pattern","national_prefix_matcher","exec","national_significant_number","captured_groups_count","nationalPrefixTransformRule","country_calling_code","national_phone_number","possible_countries","countryCallingCodes","_find_country_code","leadingDigits","indexOf","with_extension_stripped","default_country","chooseCountryByCountryCallingCode","parse_national_number","carrier_code","exactCountry","potential_national_number","numberWithoutIDD","i","MAX_LENGTH_COUNTRY_CODE"],"mappings":"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","file":"parse_.js","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of December 31th, 2018.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\n\nimport {\n\tVALID_DIGITS,\n\tVALID_PUNCTUATION,\n\tPLUS_CHARS,\n\tMIN_LENGTH_FOR_NSN,\n\tMAX_LENGTH_FOR_NSN,\n\tMAX_LENGTH_COUNTRY_CODE\n} from './constants'\n\nimport { matchesEntirely } from './util'\nimport ParseError from './ParseError'\nimport Metadata from './metadata'\nimport isViablePhoneNumber from './isViablePhoneNumber'\nimport { extractExtension } from './extension'\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber'\nimport getCountryCallingCode from './getCountryCallingCode'\nimport getNumberType, { checkNumberLengthForType } from './getNumberType_'\nimport { is_possible_number } from './isPossibleNumber_'\nimport { stripIDDPrefix } from './IDD'\nimport { parseRFC3966 } from './RFC3966'\nimport PhoneNumber from './PhoneNumber'\n\n// We don't allow input strings for parsing to be longer than 250 chars.\n// This prevents malicious input from consuming CPU.\nconst MAX_INPUT_STRING_LENGTH = 250\n\n// This consists of the plus symbol, digits, and arabic-indic digits.\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\n\n// Regular expression of trailing characters that we want to remove.\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$')\n\n// `options`:\n//  {\n//    country:\n//    {\n//      restrict - (a two-letter country code)\n//                 the phone number must be in this country\n//\n//      default - (a two-letter country code)\n//                default country to use for phone number parsing and validation\n//                (if no country code could be derived from the phone number)\n//    }\n//  }\n//\n// Returns `{ country, number }`\n//\n// Example use cases:\n//\n// ```js\n// parse('8 (800) 555-35-35', 'RU')\n// parse('8 (800) 555-35-35', 'RU', metadata)\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\n// parse('+7 800 555 35 35')\n// parse('+7 800 555 35 35', metadata)\n// ```\n//\nexport default function parse(text, options = {}, metadata)\n{\n\tmetadata = new Metadata(metadata)\n\n\t// Validate `defaultCountry`.\n\tif (options.defaultCountry && !metadata.hasCountry(options.defaultCountry))\n\t{\n\t\tif (options.v2) {\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\n\t\t}\n\t\tthrow new Error(`Unknown country: ${options.defaultCountry}`)\n\t}\n\n\t// Parse the phone number.\n\tconst { number: formatted_phone_number, ext } = parse_input(text, options.v2)\n\n\t// If the phone number is not viable then return nothing.\n\tif (!formatted_phone_number)\n\t{\n\t\tif (options.v2) {\n\t\t\tthrow new ParseError('NOT_A_NUMBER')\n\t\t}\n\t\treturn {}\n\t}\n\n\tconst\n\t{\n\t\tcountry,\n\t\tnational_number : nationalNumber,\n\t\tcountryCallingCode,\n\t\tcarrierCode\n\t}\n\t= parse_phone_number\n\t(\n\t\tformatted_phone_number,\n\t\toptions.defaultCountry,\n\t\tmetadata\n\t)\n\n\tif (!metadata.selectedCountry())\n\t{\n\t\tif (options.v2) {\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\n\t\t}\n\t\treturn {}\n\t}\n\n\t// Validate national (significant) number length.\n\tif (nationalNumber.length < MIN_LENGTH_FOR_NSN) {\n\t\t// Won't throw here because the regexp already demands length > 1.\n\t\t/* istanbul ignore if */\n\t\tif (options.v2) {\n\t\t\tthrow new ParseError('TOO_SHORT')\n\t\t}\n\t\t// Google's demo just throws an error in this case.\n\t\treturn {}\n\t}\n\n\t// Validate national (significant) number length.\n\t//\n\t// A sidenote:\n\t//\n\t// They say that sometimes national (significant) numbers\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\n\t// Such numbers will just be discarded.\n\t//\n\tif (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\n\t\tif (options.v2) {\n\t\t\tthrow new ParseError('TOO_LONG')\n\t\t}\n\t\t// Google's demo just throws an error in this case.\n\t\treturn {}\n\t}\n\n\tif (options.v2)\n\t{\n\t\tconst phoneNumber = new PhoneNumber(\n\t\t\tcountryCallingCode,\n\t\t\tnationalNumber,\n\t\t\tmetadata.metadata\n\t\t)\n\n\t\tif (country) {\n\t\t\tphoneNumber.country = country\n\t\t}\n\t\tif (carrierCode) {\n\t\t\tphoneNumber.carrierCode = carrierCode\n\t\t}\n\t\tif (ext) {\n\t\t\tphoneNumber.ext = ext\n\t\t}\n\n\t\treturn phoneNumber\n\t}\n\n\t// Check if national phone number pattern matches the number.\n\t// National number pattern is different for each country,\n\t// even for those ones which are part of the \"NANPA\" group.\n\tconst valid = country && matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) ? true : false\n\n\tif (!options.extended)\n\t{\n\t\treturn valid ? result(country, nationalNumber, ext) : {}\n\t}\n\n\treturn {\n\t\tcountry,\n\t\tcountryCallingCode,\n\t\tcarrierCode,\n\t\tvalid,\n\t\tpossible : valid ? true : (options.extended === true) && metadata.possibleLengths() && is_possible_number(nationalNumber, countryCallingCode !== undefined, metadata),\n\t\tphone : nationalNumber,\n\t\text\n\t}\n}\n\n/**\n * Extracts a parseable phone number.\n * @param  {string} text - Input.\n * @return {string}.\n */\nexport function extract_formatted_phone_number(text, v2)\n{\n\tif (!text)\n\t{\n\t\treturn\n\t}\n\n\tif (text.length > MAX_INPUT_STRING_LENGTH)\n\t{\n\t\tif (v2) {\n\t\t\tthrow new ParseError('TOO_LONG')\n\t\t}\n\t\treturn\n\t}\n\n\t// Attempt to extract a possible number from the string passed in\n\n\tconst starts_at = text.search(PHONE_NUMBER_START_PATTERN)\n\n\tif (starts_at < 0)\n\t{\n\t\treturn\n\t}\n\n\treturn text\n\t\t// Trim everything to the left of the phone number\n\t\t.slice(starts_at)\n\t\t// Remove trailing non-numerical characters\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\n}\n\n// Strips any national prefix (such as 0, 1) present in the number provided.\n// \"Carrier codes\" are only used  in Colombia and Brazil,\n// and only when dialing within those countries from a mobile phone to a fixed line number.\nexport function strip_national_prefix_and_carrier_code(number, metadata)\n{\n\tif (!number || !metadata.nationalPrefixForParsing())\n\t{\n\t\treturn { number }\n\t}\n\n\t// Attempt to parse the first digits as a national prefix\n\tconst national_prefix_pattern = new RegExp('^(?:' + metadata.nationalPrefixForParsing() + ')')\n\tconst national_prefix_matcher = national_prefix_pattern.exec(number)\n\n\t// If no national prefix is present in the phone number,\n\t// but the national prefix is optional for this country,\n\t// then consider this phone number valid.\n\t//\n\t// Google's reference `libphonenumber` implementation\n\t// wouldn't recognize such phone numbers as valid,\n\t// but I think it would perfectly make sense\n\t// to consider such phone numbers as valid\n\t// because if a national phone number was originally\n\t// formatted without the national prefix\n\t// then it must be parseable back into the original national number.\n\t// In other words, `parse(format(number))`\n\t// must always be equal to `number`.\n\t//\n\tif (!national_prefix_matcher)\n\t{\n\t\treturn { number }\n\t}\n\n\tlet national_significant_number\n\n\t// `national_prefix_for_parsing` capturing groups\n\t// (used only for really messy cases: Argentina, Brazil, Mexico, Somalia)\n\tconst captured_groups_count = national_prefix_matcher.length - 1\n\n\t// If the national number tranformation is needed then do it.\n\t//\n\t// `national_prefix_matcher[captured_groups_count]` means that\n\t// the corresponding captured group is not empty.\n\t// It can be empty if it's optional.\n\t// Example: \"0?(?:...)?\" for Argentina.\n\t//\n\tif (metadata.nationalPrefixTransformRule() && national_prefix_matcher[captured_groups_count])\n\t{\n\t\tnational_significant_number = number.replace(national_prefix_pattern, metadata.nationalPrefixTransformRule())\n\t}\n\t// Else, no transformation is necessary,\n\t// and just strip the national prefix.\n\telse\n\t{\n\t\tnational_significant_number = number.slice(national_prefix_matcher[0].length)\n\t}\n\n\tlet carrierCode\n\tif (captured_groups_count > 0)\n\t{\n\t\tcarrierCode = national_prefix_matcher[1]\n\t}\n\n\t// The following is done in `get_country_and_national_number_for_local_number()` instead.\n\t//\n\t// // Verify the parsed national (significant) number for this country\n\t// const national_number_rule = new RegExp(metadata.nationalNumberPattern())\n\t// //\n\t// // If the original number (before stripping national prefix) was viable,\n\t// // and the resultant number is not, then prefer the original phone number.\n\t// // This is because for some countries (e.g. Russia) the same digit could be both\n\t// // a national prefix and a leading digit of a valid national phone number,\n\t// // like `8` is the national prefix for Russia and both\n\t// // `8 800 555 35 35` and `800 555 35 35` are valid numbers.\n\t// if (matchesEntirely(number, national_number_rule) &&\n\t// \t\t!matchesEntirely(national_significant_number, national_number_rule))\n\t// {\n\t// \treturn number\n\t// }\n\n\t// Return the parsed national (significant) number\n   return {\n   \tnumber: national_significant_number,\n   \tcarrierCode\n   }\n}\n\nexport function find_country_code(country_calling_code, national_phone_number, metadata)\n{\n\t// Is always non-empty, because `country_calling_code` is always valid\n\tconst possible_countries = metadata.countryCallingCodes()[country_calling_code]\n\n\t// If there's just one country corresponding to the country code,\n\t// then just return it, without further phone number digits validation.\n\tif (possible_countries.length === 1)\n\t{\n\t\treturn possible_countries[0]\n\t}\n\n\treturn _find_country_code(possible_countries, national_phone_number, metadata.metadata)\n}\n\n// Changes `metadata` `country`.\nfunction _find_country_code(possible_countries, national_phone_number, metadata)\n{\n\tmetadata = new Metadata(metadata)\n\n\tfor (const country of possible_countries)\n\t{\n\t\tmetadata.country(country)\n\n\t\t// Leading digits check would be the simplest one\n\t\tif (metadata.leadingDigits())\n\t\t{\n\t\t\tif (national_phone_number &&\n\t\t\t\tnational_phone_number.search(metadata.leadingDigits()) === 0)\n\t\t\t{\n\t\t\t\treturn country\n\t\t\t}\n\t\t}\n\t\t// Else perform full validation with all of those\n\t\t// fixed-line/mobile/etc regular expressions.\n\t\telse if (getNumberType({ phone: national_phone_number, country }, undefined, metadata.metadata))\n\t\t{\n\t\t\treturn country\n\t\t}\n\t}\n}\n\n/**\n * @param  {string} text - Input.\n * @return {object} `{ ?number, ?ext }`.\n */\nfunction parse_input(text, v2)\n{\n\t// Parse RFC 3966 phone number URI.\n\tif (text && text.indexOf('tel:') === 0)\n\t{\n\t\treturn parseRFC3966(text)\n\t}\n\n\tlet number = extract_formatted_phone_number(text, v2)\n\n\t// If the phone number is not viable, then abort.\n\tif (!number || !isViablePhoneNumber(number))\n\t{\n\t\treturn {}\n\t}\n\n\t// Attempt to parse extension first, since it doesn't require region-specific\n\t// data and we want to have the non-normalised number here.\n\tconst with_extension_stripped = extractExtension(number)\n\tif (with_extension_stripped.ext)\n\t{\n\t\treturn with_extension_stripped\n\t}\n\n\treturn { number }\n}\n\n/**\n * Creates `parse()` result object.\n */\nfunction result(country, national_number, ext)\n{\n\tconst result =\n\t{\n\t\tcountry,\n\t\tphone : national_number\n\t}\n\n\tif (ext)\n\t{\n\t\tresult.ext = ext\n\t}\n\n\treturn result\n}\n\n/**\n * Parses a viable phone number.\n * Returns `{ country, countryCallingCode, national_number }`.\n */\nfunction parse_phone_number(formatted_phone_number, default_country, metadata)\n{\n\tlet { countryCallingCode, number } = extractCountryCallingCode(formatted_phone_number, default_country, metadata.metadata)\n\n\tif (!number) {\n\t\treturn { countryCallingCode }\n\t}\n\n\tlet country\n\n\tif (countryCallingCode)\n\t{\n\t\tmetadata.chooseCountryByCountryCallingCode(countryCallingCode)\n\t}\n\telse if (default_country)\n\t{\n\t\tmetadata.country(default_country)\n\t\tcountry = default_country\n\t\tcountryCallingCode = getCountryCallingCode(default_country, metadata.metadata)\n\t}\n\telse return {}\n\n\tconst { national_number, carrier_code } = parse_national_number(number, metadata)\n\n\t// Sometimes there are several countries\n\t// corresponding to the same country phone code\n\t// (e.g. NANPA countries all having `1` country phone code).\n\t// Therefore, to reliably determine the exact country,\n\t// national (significant) number should have been parsed first.\n\t//\n\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\n\t// get their countries populated with the full set of\n\t// \"phone number type\" regular expressions.\n\t//\n\tconst exactCountry = find_country_code(countryCallingCode, national_number, metadata)\n\tif (exactCountry)\n\t{\n\t\tcountry = exactCountry\n\t\tmetadata.country(country)\n\t}\n\n\treturn {\n\t\tcountry,\n\t\tcountryCallingCode,\n\t\tnational_number,\n\t\tcarrierCode: carrier_code\n\t}\n}\n\nfunction parse_national_number(number, metadata)\n{\n\tlet national_number = parseIncompletePhoneNumber(number)\n\tlet carrier_code\n\n\t// Parsing national prefixes and carrier codes\n\t// is only required for local phone numbers\n\t// but some people don't understand that\n\t// and sometimes write international phone numbers\n\t// with national prefixes (or maybe even carrier codes).\n\t// http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html\n\t// Google's original library forgives such mistakes\n\t// and so does this library, because it has been requested:\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/127\n\tconst { number: potential_national_number, carrierCode } = strip_national_prefix_and_carrier_code(national_number, metadata)\n\n\t// If metadata has \"possible lengths\" then employ the new algorythm.\n\tif (metadata.possibleLengths())\n\t{\n\t\t// We require that the NSN remaining after stripping the national prefix and\n\t\t// carrier code be long enough to be a possible length for the region.\n\t\t// Otherwise, we don't do the stripping, since the original number could be\n\t\t// a valid short number.\n\t\tswitch (checkNumberLengthForType(potential_national_number, undefined, metadata))\n\t\t{\n\t\t\tcase 'TOO_SHORT':\n\t\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\n\t\t\tcase 'INVALID_LENGTH':\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tnational_number = potential_national_number\n\t\t\t\tcarrier_code = carrierCode\n\t\t}\n\t}\n\telse\n\t{\n\t\t// If the original number (before stripping national prefix) was viable,\n\t\t// and the resultant number is not, then prefer the original phone number.\n\t\t// This is because for some countries (e.g. Russia) the same digit could be both\n\t\t// a national prefix and a leading digit of a valid national phone number,\n\t\t// like `8` is the national prefix for Russia and both\n\t\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\n\t\tif (matchesEntirely(national_number, metadata.nationalNumberPattern()) &&\n\t\t\t\t!matchesEntirely(potential_national_number, metadata.nationalNumberPattern()))\n\t\t{\n\t\t\t// Keep the number without stripping national prefix.\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnational_number = potential_national_number\n\t\t\tcarrier_code = carrierCode\n\t\t}\n\t}\n\n\treturn {\n\t\tnational_number,\n\t\tcarrier_code\n\t}\n}\n\n// Determines the country for a given (possibly incomplete) phone number.\n// export function get_country_from_phone_number(number, metadata)\n// {\n// \treturn parse_phone_number(number, null, metadata).country\n// }\n\n// Parses a formatted phone number\n// and returns `{ countryCallingCode, number }`\n// where `number` is just the \"number\" part\n// which is left after extracting `countryCallingCode`\n// and is not necessarily a \"national (significant) number\"\n// and might as well contain national prefix.\n//\nexport function extractCountryCallingCode(number, country, metadata)\n{\n\tnumber = parseIncompletePhoneNumber(number)\n\n\tif (!number)\n\t{\n\t\treturn {}\n\t}\n\n\t// If this is not an international phone number,\n\t// then don't extract country phone code.\n\tif (number[0] !== '+')\n\t{\n\t\t// Convert an \"out-of-country\" dialing phone number\n\t\t// to a proper international phone number.\n\t\tconst numberWithoutIDD = stripIDDPrefix(number, country, metadata)\n\n\t\t// If an IDD prefix was stripped then\n\t\t// convert the number to international one\n\t\t// for subsequent parsing.\n\t\tif (numberWithoutIDD && numberWithoutIDD !== number) {\n\t\t\tnumber = '+' + numberWithoutIDD\n\t\t} else {\n\t\t\treturn { number }\n\t\t}\n\t}\n\n\t// Fast abortion: country codes do not begin with a '0'\n\tif (number[1] === '0')\n\t{\n\t\treturn {}\n\t}\n\n\tmetadata = new Metadata(metadata)\n\n\t// The thing with country phone codes\n\t// is that they are orthogonal to each other\n\t// i.e. there's no such country phone code A\n\t// for which country phone code B exists\n\t// where B starts with A.\n\t// Therefore, while scanning digits,\n\t// if a valid country code is found,\n\t// that means that it is the country code.\n\t//\n\tlet i = 2\n\twhile (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length)\n\t{\n\t\tconst countryCallingCode = number.slice(1, i)\n\n\t\tif (metadata.countryCallingCodes()[countryCallingCode])\n\t\t{\n\t\t\treturn {\n\t\t\t\tcountryCallingCode,\n\t\t\t\tnumber: number.slice(i)\n\t\t\t}\n\t\t}\n\n\t\ti++\n\t}\n\n\treturn {}\n}\n"]}