{"version":3,"sources":["../source/PhoneNumberMatcher.js"],"names":["INNER_MATCHES","pZ","PZ","leadLimit","punctuationLimit","digitBlockLimit","MAX_LENGTH_FOR_NSN","MAX_LENGTH_COUNTRY_CODE","blockLimit","punctuation","VALID_PUNCTUATION","digitSequence","pNd","PATTERN","LEAD_CLASS","EXTN_PATTERNS_FOR_MATCHING","UNWANTED_END_CHAR_PATTERN","RegExp","_pN","_pL","NON_DIGITS_PATTERN","MAX_SAFE_INTEGER","Number","Math","pow","PhoneNumberMatcher","text","options","metadata","state","searchIndex","defaultCountry","undefined","leniency","extended","maxTries","TypeError","Leniency","matches","exec","candidate","offset","index","match","parseAndVerify","extractInnerMatch","v2","phoneNumber","PhoneNumber","country","phone","ext","startsAt","endsAt","number","innerMatchPattern","isFirstMatch","possibleInnerMatch","group","slice","possible","result","length","lastMatch","find","hasNext","Error"],"mappings":";;;;;;;;qjBAAA;;;;;;AAMA;;;;AAEA;;AAMA;;AAEA;;AAKA;;AAQA;;;;AACA;;;;AACA;;;;AACA;;;;AAEA;;AAEA;;;;;;;;AAEA;;;;;;;;;;AAUA,IAAMA,gBACN;AACC;AACA,WAFD;;AAIC;AACA;AACA,YAND;;AAQC;AACA;AATD,QAUOC,OAVP,WAUeA,OAVf,SAUqBA,OAVrB;;AAYC;AACA;AACA;AAdD,0BAeyBA,OAfzB;;AAiBC;AAjBD,SAkBQA,OAlBR;;AAoBC;AACGA,OArBJ,UAqBWC,OArBX,QADA;;AAyBA;AACA,IAAMC,YAAY,iBAAM,CAAN,EAAS,CAAT,CAAlB;;AAEA;AACA,IAAMC,mBAAmB,iBAAM,CAAN,EAAS,CAAT,CAAzB;;AAEA;;;AAGA,IAAMC,kBAAkBC,gCAAqBC,kCAA7C;;AAEA;AACA;AACA,IAAMC,aAAa,iBAAM,CAAN,EAASH,eAAT,CAAnB;;AAEA;AACA,IAAMI,cAAc,MAAIC,4BAAJ,SAA2BN,gBAA/C;;AAEA;AACA,IAAMO,gBAAgBC,WAAM,iBAAM,CAAN,EAASP,eAAT,CAA5B;;AAEA;;;;;;;;;;;;;;;;AAgBA,IAAMQ,UAAU,QAAQC,4BAAR,GAAqBL,WAArB,GAAmC,GAAnC,GAAyCN,SAAzC,GACbQ,aADa,GACG,KADH,GACWF,WADX,GACyBE,aADzB,GACyC,GADzC,GAC+CH,UAD/C,GAEb,KAFa,GAELO,qCAFK,GAEwB,IAFxC;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMC,4BAA4B,IAAIC,MAAJ,QAAgBC,QAAhB,GAAsBC,QAAtB,UAAlC;;AAEA,IAAMC,qBAAqB,OAA3B;;AAEA,IAAMC,mBAAmBC,OAAOD,gBAAP,IAA2BE,KAAKC,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkB,CAAtE;;AAEA;;;;;;;;;;;IAUqBC,kB;;AAQnB;;;;;;;;;;;;;;;;AANA;AAqBA,gCACA;AAAA,QADYC,IACZ,uEADmB,EACnB;AAAA,QADuBC,OACvB,uEADiC,EACjC;AAAA,QADqCC,QACrC;;AAAA;;AAAA,SArBAC,KAqBA,GArBQ,WAqBR;AAAA,SAlBAC,WAkBA,GAlBc,CAkBd;;AACEH,2BACKA,OADL;AAEEI,sBAAiBJ,QAAQI,cAAR,IAA0B,kCAAmBJ,QAAQI,cAA3B,EAA2CH,QAA3C,CAA1B,GAAiFD,QAAQI,cAAzF,GAA0GC,SAF7H;AAGEC,gBAAWN,QAAQM,QAAR,IAAoBN,QAAQO,QAA5B,GAAuC,UAAvC,GAAoD,OAHjE;AAIEC,gBAAWR,QAAQQ,QAAR,IAAoBd;AAJjC;;AAOF,QAAI,CAACM,QAAQM,QAAb,EAAuB;AACtB,YAAM,IAAIG,SAAJ,CAAc,yBAAd,CAAN;AACA;;AAED,QAAIT,QAAQQ,QAAR,GAAmB,CAAvB,EAA0B;AACzB,YAAM,IAAIC,SAAJ,CAAc,yBAAd,CAAN;AACA;;AAED,SAAKV,IAAL,GAAYA,IAAZ;AACA,SAAKC,OAAL,GAAeA,OAAf;AACE,SAAKC,QAAL,GAAgBA,QAAhB;;AAEF;AACA,SAAKK,QAAL,GAAgBI,mBAASV,QAAQM,QAAjB,CAAhB;;AAEA,QAAI,CAAC,KAAKA,QAAV,EACA;AACC,YAAM,IAAIG,SAAJ,wBAAmCT,QAAQM,QAA3C,OAAN;AACA;;AAED;AACA,SAAKE,QAAL,GAAgBR,QAAQQ,QAAxB;;AAEA,SAAKtB,OAAL,GAAe,IAAII,MAAJ,CAAWJ,OAAX,EAAoB,IAApB,CAAf;AACC;;AAED;;;;;;;;;AArDA;;;;;2BA4DM;AACP;AACC;AACA;;AAEA,UAAIyB,gBAAJ;AACA,aAAQ,KAAKH,QAAL,GAAgB,CAAjB,IAAuB,CAACG,UAAU,KAAKzB,OAAL,CAAa0B,IAAb,CAAkB,KAAKb,IAAvB,CAAX,MAA6C,IAA3E,EACA;AACC,YAAIc,YAAYF,QAAQ,CAAR,CAAhB;AACA,YAAMG,SAASH,QAAQI,KAAvB;;AAEAF,oBAAY,iCAAkBA,SAAlB,CAAZ;;AAEA,YAAI,mCAAoBA,SAApB,EAA+BC,MAA/B,EAAuC,KAAKf,IAA5C,CAAJ,EACA;AACC,cAAMiB;AACL;AACA,eAAKC,cAAL,CAAoBJ,SAApB,EAA+BC,MAA/B,EAAuC,KAAKf,IAA5C;AACA;AACA;AAFA,aAGG,KAAKmB,iBAAL,CAAuBL,SAAvB,EAAkCC,MAAlC,EAA0C,KAAKf,IAA/C,CALJ;;AAOA,cAAIiB,KAAJ,EAAW;AACV,gBAAI,KAAKhB,OAAL,CAAamB,EAAjB,EAAqB;AACpB,kBAAMC,cAAc,IAAIC,qBAAJ,CAAgBL,MAAMM,OAAtB,EAA+BN,MAAMO,KAArC,EAA4C,KAAKtB,QAAjD,CAApB;AACA,kBAAIe,MAAMQ,GAAV,EAAe;AACdJ,4BAAYI,GAAZ,GAAkBR,MAAMQ,GAAxB;AACA;AACD,qBAAO;AACNC,0BAAUT,MAAMS,QADV;AAENC,wBAAQV,MAAMU,MAFR;AAGNC,wBAAQP;AAHF,eAAP;AAKA;AACD,mBAAOJ,KAAP;AACA;AACD;;AAED,aAAKR,QAAL;AACA;AACD;;AAEA;;;;;;;sCAIkBK,S,EAAWC,M,EAAQf,I,EACrC;AACE,2BAAgC1B,aAAhC,kHACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,YADWuD,iBACX;;AACE,YAAIC,eAAe,IAAnB;AACA,YAAIlB,gBAAJ;AACA,YAAMmB,qBAAqB,IAAIxC,MAAJ,CAAWsC,iBAAX,EAA8B,GAA9B,CAA3B;AACA,eAAO,CAACjB,UAAUmB,mBAAmBlB,IAAnB,CAAwBC,SAAxB,CAAX,MAAmD,IAAnD,IAA2D,KAAKL,QAAL,GAAgB,CAAlF,EACA;AACE,cAAIqB,YAAJ,EACA;AACE;AACA,gBAAME,SAAQ,+BAEZ1C,yBAFY,EAGZwB,UAAUmB,KAAV,CAAgB,CAAhB,EAAmBrB,QAAQI,KAA3B,CAHY,CAAd;;AAMA,gBAAMC,SAAQ,KAAKC,cAAL,CAAoBc,MAApB,EAA2BjB,MAA3B,EAAmCf,IAAnC,CAAd;AACA,gBAAIiB,MAAJ,EAAW;AACT,qBAAOA,MAAP;AACD;;AAED,iBAAKR,QAAL;AACAqB,2BAAe,KAAf;AACD;;AAED,cAAME,QAAQ,+BAEb1C,yBAFa,EAGbsB,QAAQ,CAAR,CAHa,CAAd;;AAMA;AACA;AACA;AACA,cAAMK,QAAQ,KAAKC,cAAL,CAAoBc,KAApB,EAA2BjB,SAASH,QAAQI,KAA5C,EAAmDhB,IAAnD,CAAd;AACA,cAAIiB,KAAJ,EAAW;AACT,mBAAOA,KAAP;AACD;;AAED,eAAKR,QAAL;AACD;AACF;AACF;;AAED;;;;;;;;;;;;mCASeK,S,EAAWC,M,EAAQf,I,EAClC;AACE,UAAI,CAAC,gCAAiBc,SAAjB,EAA4BC,MAA5B,EAAoCf,IAApC,EAA0C,KAAKC,OAAL,CAAaM,QAAvD,CAAL,EAAuE;AACrE;AACF;;AAEA,UAAMqB,SAAS,sBACbd,SADa,EACF;AACTN,kBAAU,IADD;AAETH,wBAAgB,KAAKJ,OAAL,CAAaI;AAFpB,OADE,EAKb,KAAKH,QALQ,CAAf;;AAQA,UAAI,CAAC0B,OAAOM,QAAZ,EAAsB;AACpB;AACD;;AAED,UAAI,KAAK3B,QAAL,CAAcqB,MAAd,EAAsBd,SAAtB,EAAiC,KAAKZ,QAAtC,CAAJ,EACA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAMiC,SAAS;AACbT,oBAAWX,MADE;AAEbY,kBAAWZ,SAASD,UAAUsB,MAFjB;AAGbb,mBAAWK,OAAOL,OAHL;AAIbC,iBAAWI,OAAOJ;AAJL,SAAf;;AAOA,YAAII,OAAOH,GAAX,EAAgB;AACdU,iBAAOV,GAAP,GAAaG,OAAOH,GAApB;AACD;;AAED,eAAOU,MAAP;AACD;AACF;;;8BAGD;AACE,UAAI,KAAKhC,KAAL,KAAe,WAAnB,EACA;AACE,aAAKkC,SAAL,GAAiB,KAAKC,IAAL,EAAjB,CADF,CAC+B;;AAE7B,YAAI,KAAKD,SAAT,EACA;AACE;AACA,eAAKlC,KAAL,GAAa,OAAb;AACD,SAJD,MAMA;AACE,eAAKA,KAAL,GAAa,MAAb;AACD;AACF;;AAED,aAAO,KAAKA,KAAL,KAAe,OAAtB;AACD;;;2BAGD;AACE;AACA,UAAI,CAAC,KAAKoC,OAAL,EAAL,EACA;AACE,cAAM,IAAIC,KAAJ,CAAU,iBAAV,CAAN;AACD;;AAED;AACA,UAAML,SAAS,KAAKE,SAApB;AACA,WAAKA,SAAL,GAAiB,IAAjB;AACA,WAAKlC,KAAL,GAAa,WAAb;AACA,aAAOgC,MAAP;AACD;;;;;;kBAlPkBpC,kB","file":"PhoneNumberMatcher.js","sourcesContent":["/**\n * A port of Google's `PhoneNumberMatcher.java`.\n * https://github.com/googlei18n/libphonenumber/blob/master/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberMatcher.java\n * Date: 08.03.2018.\n */\n\nimport PhoneNumber from './PhoneNumber'\n\nimport {\n  MAX_LENGTH_FOR_NSN,\n  MAX_LENGTH_COUNTRY_CODE,\n  VALID_PUNCTUATION\n} from './constants'\n\nimport { EXTN_PATTERNS_FOR_MATCHING } from './extension'\n\nimport {\n\tlimit,\n\ttrimAfterFirstMatch\n} from './findNumbers/util'\n\nimport {\n\t_pL,\n\t_pN,\n\tpZ,\n\tPZ,\n\tpNd\n} from './findNumbers/utf-8'\n\nimport Leniency from './findNumbers/Leniency'\nimport parsePreCandidate from './findNumbers/parsePreCandidate'\nimport isValidPreCandidate from './findNumbers/isValidPreCandidate'\nimport isValidCandidate, { LEAD_CLASS } from './findNumbers/isValidCandidate'\n\nimport { isSupportedCountry } from './metadata'\n\nimport parseNumber from './parse_'\n\n/**\n * Patterns used to extract phone numbers from a larger phone-number-like pattern. These are\n * ordered according to specificity. For example, white-space is last since that is frequently\n * used in numbers, not just to separate two numbers. We have separate patterns since we don't\n * want to break up the phone-number-like text on more than one different kind of symbol at one\n * time, although symbols of the same type (e.g. space) can be safely grouped together.\n *\n * Note that if there is a match, we will always check any text found up to the first match as\n * well.\n */\nconst INNER_MATCHES =\n[\n\t// Breaks on the slash - e.g. \"651-234-2345/332-445-1234\"\n\t'\\\\/+(.*)/',\n\n\t// Note that the bracket here is inside the capturing group, since we consider it part of the\n\t// phone number. Will match a pattern like \"(650) 223 3345 (754) 223 3321\".\n\t'(\\\\([^(]*)',\n\n\t// Breaks on a hyphen - e.g. \"12345 - 332-445-1234 is my number.\"\n\t// We require a space on either side of the hyphen for it to be considered a separator.\n\t`(?:${pZ}-|-${pZ})${pZ}*(.+)`,\n\n\t// Various types of wide hyphens. Note we have decided not to enforce a space here, since it's\n\t// possible that it's supposed to be used to break two numbers without spaces, and we haven't\n\t// seen many instances of it used within a number.\n\t`[\\u2012-\\u2015\\uFF0D]${pZ}*(.+)`,\n\n\t// Breaks on a full stop - e.g. \"12345. 332-445-1234 is my number.\"\n\t`\\\\.+${pZ}*([^.]+)`,\n\n\t// Breaks on space - e.g. \"3324451234 8002341234\"\n\t`${pZ}+(${PZ}+)`\n]\n\n// Limit on the number of leading (plus) characters.\nconst leadLimit = limit(0, 2)\n\n// Limit on the number of consecutive punctuation characters.\nconst punctuationLimit = limit(0, 4)\n\n/* The maximum number of digits allowed in a digit-separated block. As we allow all digits in a\n * single block, set high enough to accommodate the entire national number and the international\n * country code. */\nconst digitBlockLimit = MAX_LENGTH_FOR_NSN + MAX_LENGTH_COUNTRY_CODE\n\n// Limit on the number of blocks separated by punctuation.\n// Uses digitBlockLimit since some formats use spaces to separate each digit.\nconst blockLimit = limit(0, digitBlockLimit)\n\n/* A punctuation sequence allowing white space. */\nconst punctuation = `[${VALID_PUNCTUATION}]` + punctuationLimit\n\n// A digits block without punctuation.\nconst digitSequence = pNd + limit(1, digitBlockLimit)\n\n/**\n * Phone number pattern allowing optional punctuation.\n * The phone number pattern used by `find()`, similar to\n * VALID_PHONE_NUMBER, but with the following differences:\n * <ul>\n *   <li>All captures are limited in order to place an upper bound to the text matched by the\n *       pattern.\n * <ul>\n *   <li>Leading punctuation / plus signs are limited.\n *   <li>Consecutive occurrences of punctuation are limited.\n *   <li>Number of digits is limited.\n * </ul>\n *   <li>No whitespace is allowed at the start or end.\n *   <li>No alpha digits (vanity numbers such as 1-800-SIX-FLAGS) are currently supported.\n * </ul>\n */\nconst PATTERN = '(?:' + LEAD_CLASS + punctuation + ')' + leadLimit\n\t+ digitSequence + '(?:' + punctuation + digitSequence + ')' + blockLimit\n\t+ '(?:' + EXTN_PATTERNS_FOR_MATCHING + ')?'\n\n// Regular expression of trailing characters that we want to remove.\n// We remove all characters that are not alpha or numerical characters.\n// The hash character is retained here, as it may signify\n// the previous block was an extension.\n//\n// // Don't know what does '&&' mean here.\n// const UNWANTED_END_CHAR_PATTERN = new RegExp(`[[\\\\P{N}&&\\\\P{L}]&&[^#]]+$`)\n//\nconst UNWANTED_END_CHAR_PATTERN = new RegExp(`[^${_pN}${_pL}#]+$`)\n\nconst NON_DIGITS_PATTERN = /(\\D+)/\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1\n\n/**\n * A stateful class that finds and extracts telephone numbers from {@linkplain CharSequence text}.\n * Instances can be created using the {@linkplain PhoneNumberUtil#findNumbers factory methods} in\n * {@link PhoneNumberUtil}.\n *\n * <p>Vanity numbers (phone numbers using alphabetic digits such as <tt>1-800-SIX-FLAGS</tt> are\n * not found.\n *\n * <p>This class is not thread-safe.\n */\nexport default class PhoneNumberMatcher\n{\n  /** The iteration tristate. */\n  state = 'NOT_READY'\n\n  /** The next index to start searching at. Undefined in {@link State#DONE}. */\n  searchIndex = 0\n\n  /**\n   * Creates a new instance. See the factory methods in {@link PhoneNumberUtil} on how to obtain a\n   * new instance.\n   *\n   * @param util  the phone number util to use\n   * @param text  the character sequence that we will search, null for no text\n   * @param country  the country to assume for phone numbers not written in international format\n   *     (with a leading plus, or with the international dialing prefix of the specified region).\n   *     May be null or \"ZZ\" if only numbers with a leading plus should be\n   *     considered.\n   * @param leniency  the leniency to use when evaluating candidate phone numbers\n   * @param maxTries  the maximum number of invalid numbers to try before giving up on the text.\n   *     This is to cover degenerate cases where the text has a lot of false positives in it. Must\n   *     be {@code >= 0}.\n   */\n  constructor(text = '', options = {}, metadata)\n  {\n    options = {\n      ...options,\n      defaultCountry : options.defaultCountry && isSupportedCountry(options.defaultCountry, metadata) ? options.defaultCountry : undefined,\n      leniency : options.leniency || options.extended ? 'POSSIBLE' : 'VALID',\n      maxTries : options.maxTries || MAX_SAFE_INTEGER\n    }\n\n\t\tif (!options.leniency) {\n\t\t\tthrow new TypeError('`Leniency` not supplied')\n\t\t}\n\n\t\tif (options.maxTries < 0) {\n\t\t\tthrow new TypeError('`maxTries` not supplied')\n\t\t}\n\n\t\tthis.text = text\n\t\tthis.options = options\n    this.metadata = metadata\n\n\t\t/** The degree of validation requested. */\n\t\tthis.leniency = Leniency[options.leniency]\n\n\t\tif (!this.leniency)\n\t\t{\n\t\t\tthrow new TypeError(`Unknown leniency: ${options.leniency}.`)\n\t\t}\n\n\t\t/** The maximum number of retries after matching an invalid number. */\n\t\tthis.maxTries = options.maxTries\n\n\t\tthis.PATTERN = new RegExp(PATTERN, 'ig')\n  }\n\n  /**\n   * Attempts to find the next subsequence in the searched sequence on or after {@code searchIndex}\n   * that represents a phone number. Returns the next match, null if none was found.\n   *\n   * @param index  the search index to start searching at\n   * @return  the phone number match found, null if none can be found\n   */\n\tfind() // (index)\n\t{\n\t\t// // Reset the regular expression.\n\t\t// this.PATTERN.lastIndex = index\n\n\t\tlet matches\n\t\twhile ((this.maxTries > 0) && (matches = this.PATTERN.exec(this.text)) !== null)\n\t\t{\n\t\t\tlet candidate = matches[0]\n\t\t\tconst offset = matches.index\n\n\t\t\tcandidate = parsePreCandidate(candidate)\n\n\t\t\tif (isValidPreCandidate(candidate, offset, this.text))\n\t\t\t{\n\t\t\t\tconst match =\n\t\t\t\t\t// Try to come up with a valid match given the entire candidate.\n\t\t\t\t\tthis.parseAndVerify(candidate, offset, this.text)\n\t\t\t\t\t// If that failed, try to find an \"inner match\" -\n\t\t\t\t\t// there might be a phone number within this candidate.\n\t\t\t\t\t|| this.extractInnerMatch(candidate, offset, this.text)\n\n\t\t\t\tif (match) {\n\t\t\t\t\tif (this.options.v2) {\n\t\t\t\t\t\tconst phoneNumber = new PhoneNumber(match.country, match.phone, this.metadata)\n\t\t\t\t\t\tif (match.ext) {\n\t\t\t\t\t\t\tphoneNumber.ext = match.ext\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tstartsAt: match.startsAt,\n\t\t\t\t\t\t\tendsAt: match.endsAt,\n\t\t\t\t\t\t\tnumber: phoneNumber\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn match\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.maxTries--\n\t\t}\n\t}\n\n  /**\n   * Attempts to extract a match from `candidate`\n   * if the whole candidate does not qualify as a match.\n   */\n  extractInnerMatch(candidate, offset, text)\n  {\n    for (const innerMatchPattern of INNER_MATCHES)\n    {\n      let isFirstMatch = true\n      let matches\n      const possibleInnerMatch = new RegExp(innerMatchPattern, 'g')\n      while ((matches = possibleInnerMatch.exec(candidate)) !== null && this.maxTries > 0)\n      {\n        if (isFirstMatch)\n        {\n          // We should handle any group before this one too.\n          const group = trimAfterFirstMatch\n          (\n            UNWANTED_END_CHAR_PATTERN,\n            candidate.slice(0, matches.index)\n          )\n\n          const match = this.parseAndVerify(group, offset, text)\n          if (match) {\n            return match\n          }\n\n          this.maxTries--\n          isFirstMatch = false\n        }\n\n        const group = trimAfterFirstMatch\n        (\n        \tUNWANTED_END_CHAR_PATTERN,\n        \tmatches[1]\n        )\n\n        // Java code does `groupMatcher.start(1)` here,\n        // but there's no way in javascript to get a group match start index,\n        // therefore using the overall match start index `matches.index`.\n        const match = this.parseAndVerify(group, offset + matches.index, text)\n        if (match) {\n          return match\n        }\n\n        this.maxTries--\n      }\n    }\n  }\n\n  /**\n   * Parses a phone number from the `candidate` using `parseNumber` and\n   * verifies it matches the requested `leniency`. If parsing and verification succeed,\n   * a corresponding `PhoneNumberMatch` is returned, otherwise this method returns `null`.\n   *\n   * @param candidate  the candidate match\n   * @param offset  the offset of {@code candidate} within {@link #text}\n   * @return  the parsed and validated phone number match, or null\n   */\n  parseAndVerify(candidate, offset, text)\n  {\n    if (!isValidCandidate(candidate, offset, text, this.options.leniency)) {\n      return\n  \t}\n\n    const number = parseNumber(\n      candidate, {\n        extended: true,\n        defaultCountry: this.options.defaultCountry\n      },\n      this.metadata\n    )\n\n    if (!number.possible) {\n      return\n    }\n\n    if (this.leniency(number, candidate, this.metadata))\n    {\n      // // We used parseAndKeepRawInput to create this number,\n      // // but for now we don't return the extra values parsed.\n      // // TODO: stop clearing all values here and switch all users over\n      // // to using rawInput() rather than the rawString() of PhoneNumberMatch.\n      // number.clearCountryCodeSource()\n      // number.clearRawInput()\n      // number.clearPreferredDomesticCarrierCode()\n\n      const result = {\n        startsAt : offset,\n        endsAt   : offset + candidate.length,\n        country  : number.country,\n        phone    : number.phone\n      }\n\n      if (number.ext) {\n        result.ext = number.ext\n      }\n\n      return result\n    }\n  }\n\n  hasNext()\n  {\n    if (this.state === 'NOT_READY')\n    {\n      this.lastMatch = this.find() // (this.searchIndex)\n\n      if (this.lastMatch)\n      {\n        // this.searchIndex = this.lastMatch.endsAt\n        this.state = 'READY'\n      }\n      else\n      {\n        this.state = 'DONE'\n      }\n    }\n\n    return this.state === 'READY'\n  }\n\n  next()\n  {\n    // Check the state and find the next match as a side-effect if necessary.\n    if (!this.hasNext())\n    {\n      throw new Error('No next element')\n    }\n\n    // Don't retain that memory any longer than necessary.\n    const result = this.lastMatch\n    this.lastMatch = null\n    this.state = 'NOT_READY'\n    return result\n  }\n}"]}