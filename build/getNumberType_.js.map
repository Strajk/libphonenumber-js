{"version":3,"sources":["../source/getNumberType_.js"],"names":["getNumberType","is_of_type","checkNumberLengthForType","NON_FIXED_LINE_PHONE_TYPES","input","options","metadata","country","Metadata","hasCountry","Error","nationalNumber","v2","phone","nationalNumberPattern","type","pattern","_type","possibleLengths","indexOf","length","type_info","possible_lengths","mobile_type","actual_length","minimum_length"],"mappings":"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","file":"getNumberType_.js","sourcesContent":["import Metadata from './metadata'\nimport { matchesEntirely, mergeArrays } from './util'\n\nconst NON_FIXED_LINE_PHONE_TYPES =\n[\n\t'MOBILE',\n\t'PREMIUM_RATE',\n\t'TOLL_FREE',\n\t'SHARED_COST',\n\t'VOIP',\n\t'PERSONAL_NUMBER',\n\t'PAGER',\n\t'UAN',\n\t'VOICEMAIL'\n]\n\n// Finds out national phone number type (fixed line, mobile, etc)\nexport default function getNumberType(input, options = {}, metadata)\n{\n\t// When `parse()` returned `{}`\n\t// meaning that the phone number is not a valid one.\n\tif (!input.country)\n\t{\n\t\treturn\n\t}\n\n\tmetadata = new Metadata(metadata)\n\n\tif (!metadata.hasCountry(input.country))\n\t{\n\t\tthrow new Error(`Unknown country: ${input.country}`)\n\t}\n\n\tconst nationalNumber = options.v2 ? input.nationalNumber : input.phone\n\tmetadata.country(input.country)\n\n\t// The following is copy-pasted from the original function:\n\t// https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\n\n\t// Is this national number even valid for this country\n\tif (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern()))\n\t{\n\t\treturn\n\t}\n\n\t// Is it fixed line number\n\tif (is_of_type(nationalNumber, 'FIXED_LINE', metadata))\n\t{\n\t\t// Because duplicate regular expressions are removed\n\t\t// to reduce metadata size, if \"mobile\" pattern is \"\"\n\t\t// then it means it was removed due to being a duplicate of the fixed-line pattern.\n\t\t//\n\t\tif (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '')\n\t\t{\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\n\t\t}\n\n\t\t// v1 metadata.\n\t\t// Legacy.\n\t\t// Deprecated.\n\t\tif (!metadata.type('MOBILE'))\n\t\t{\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\n\t\t}\n\n\t\t// Check if the number happens to qualify as both fixed line and mobile.\n\t\t// (no such country in the minimal metadata set)\n\t\t/* istanbul ignore if */\n\t\tif (is_of_type(nationalNumber, 'MOBILE', metadata))\n\t\t{\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\n\t\t}\n\n\t\treturn 'FIXED_LINE'\n\t}\n\n\tfor (const _type of NON_FIXED_LINE_PHONE_TYPES)\n\t{\n\t\tif (is_of_type(nationalNumber, _type, metadata))\n\t\t{\n\t\t\treturn _type\n\t\t}\n\t}\n}\n\nexport function is_of_type(nationalNumber, type, metadata)\n{\n\ttype = metadata.type(type)\n\n\tif (!type || !type.pattern())\n\t{\n\t\treturn false\n\t}\n\n\t// Check if any possible number lengths are present;\n\t// if so, we use them to avoid checking\n\t// the validation pattern if they don't match.\n\t// If they are absent, this means they match\n\t// the general description, which we have\n\t// already checked before a specific number type.\n\tif (type.possibleLengths() &&\n\t\ttype.possibleLengths().indexOf(nationalNumber.length) < 0)\n\t{\n\t\treturn false\n\t}\n\n\treturn matchesEntirely(nationalNumber, type.pattern())\n}\n\n// Should only be called for the \"new\" metadata which has \"possible lengths\".\nexport function checkNumberLengthForType(nationalNumber, type, metadata)\n{\n\tconst type_info = metadata.type(type)\n\n\t// There should always be \"<possiblePengths/>\" set for every type element.\n\t// This is declared in the XML schema.\n\t// For size efficiency, where a sub-description (e.g. fixed-line)\n\t// has the same \"<possiblePengths/>\" as the \"general description\", this is missing,\n\t// so we fall back to the \"general description\". Where no numbers of the type\n\t// exist at all, there is one possible length (-1) which is guaranteed\n\t// not to match the length of any real phone number.\n\tlet possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths()\n\t// let local_lengths    = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()\n\n\tif (type === 'FIXED_LINE_OR_MOBILE')\n\t{\n\t\t// No such country in metadata.\n\t\t/* istanbul ignore next */\n\t\tif (!metadata.type('FIXED_LINE'))\n\t\t{\n\t\t\t// The rare case has been encountered where no fixedLine data is available\n\t\t\t// (true for some non-geographical entities), so we just check mobile.\n\t\t\treturn checkNumberLengthForType(nationalNumber, 'MOBILE', metadata)\n\t\t}\n\n\t\tconst mobile_type = metadata.type('MOBILE')\n\n\t\tif (mobile_type)\n\t\t{\n\t\t\t// Merge the mobile data in if there was any. \"Concat\" creates a new\n\t\t\t// array, it doesn't edit possible_lengths in place, so we don't need a copy.\n\t\t\t// Note that when adding the possible lengths from mobile, we have\n\t\t\t// to again check they aren't empty since if they are this indicates\n\t\t\t// they are the same as the general desc and should be obtained from there.\n\t\t\tpossible_lengths = mergeArrays(possible_lengths, mobile_type.possibleLengths())\n\t\t\t// The current list is sorted; we need to merge in the new list and\n\t\t\t// re-sort (duplicates are okay). Sorting isn't so expensive because\n\t\t\t// the lists are very small.\n\n\t\t\t// if (local_lengths)\n\t\t\t// {\n\t\t\t// \tlocal_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())\n\t\t\t// }\n\t\t\t// else\n\t\t\t// {\n\t\t\t// \tlocal_lengths = mobile_type.possibleLengthsLocal()\n\t\t\t// }\n\t\t}\n\t}\n\t// If the type doesn't exist then return 'INVALID_LENGTH'.\n\telse if (type && !type_info)\n\t{\n\t\treturn 'INVALID_LENGTH'\n\t}\n\n\tconst actual_length = nationalNumber.length\n\n\t// In `libphonenumber-js` all \"local-only\" formats are dropped for simplicity.\n\t// // This is safe because there is never an overlap beween the possible lengths\n\t// // and the local-only lengths; this is checked at build time.\n\t// if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)\n\t// {\n\t// \treturn 'IS_POSSIBLE_LOCAL_ONLY'\n\t// }\n\n\tconst minimum_length = possible_lengths[0]\n\n\tif (minimum_length === actual_length)\n\t{\n\t\treturn 'IS_POSSIBLE'\n\t}\n\n\tif (minimum_length > actual_length)\n\t{\n\t\treturn 'TOO_SHORT'\n\t}\n\n\tif (possible_lengths[possible_lengths.length - 1] < actual_length)\n\t{\n\t\treturn 'TOO_LONG'\n\t}\n\n\t// We skip the first element since we've already checked it.\n\treturn possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH'\n}"]}