{"version":3,"sources":["../source/extension.js"],"names":["extractExtension","RFC3966_EXTN_PREFIX","CAPTURING_EXTN_DIGITS","VALID_DIGITS","create_extension_pattern","purpose","single_extension_characters","EXTN_PATTERNS_FOR_PARSING","EXTN_PATTERNS_FOR_MATCHING","EXTN_PATTERN","RegExp","number","start","search","number_without_extension","slice","matches","match","i","length","ext"],"mappings":";;;;;;QA2EgBA,gB,GAAAA,gB;;AA3EhB;;AAEA;AACA,IAAMC,sBAAsB,OAA5B;;AAEA;AACA;AACA,IAAMC,wBAAwB,OAAOC,uBAAP,GAAsB,SAApD;;AAEA;;;;;;;;;;;;;;;AAeA,SAASC,wBAAT,CAAkCC,OAAlC,EACA;AACC;AACA,KAAIC,8BAA8B,uBAAlC;;AAEA,SAAQD,OAAR;AAEC;AACA;AACA,OAAK,SAAL;AACCC,iCAA8B,OAAOA,2BAArC;AALF;;AAQA,QAAOL,sBACNC,qBADM,GACkB,GADlB,GAEN,cAFM,GAGN,iEAHM;AAIN;AACA,sBALM,GAMN,GANM,GAMAI,2BANA,GAM8B,iCAN9B,GAON,4BAPM,GAQNJ,qBARM,GAQkB,KARlB,GASN,SATM,GASMC,uBATN,GASqB,UAT5B;AAUA;;AAED;;;;;;;;;;;;;;;AAeO,IAAMI,gEAA4BH,yBAAyB,SAAzB,CAAlC;;AAEA,IAAMI,kEAA6BJ,yBAAyB,UAAzB,CAAnC;;AAEP;AACA;AACA,IAAMK,eAAe,IAAIC,MAAJ,CAAW,QAAQH,yBAAR,GAAoC,IAA/C,EAAqD,GAArD,CAArB;;AAEA;AACA;AACA;AACO,SAASP,gBAAT,CAA0BW,MAA1B,EACP;AACC,KAAMC,QAAQD,OAAOE,MAAP,CAAcJ,YAAd,CAAd;AACA,KAAIG,QAAQ,CAAZ,EAAe;AACd,SAAO,EAAP;AACA;;AAED;AACA;AACA,KAAME,2BAA2BH,OAAOI,KAAP,CAAa,CAAb,EAAgBH,KAAhB,CAAjC;;AAEA,KAAMI,UAAUL,OAAOM,KAAP,CAAaR,YAAb,CAAhB;AACA,KAAIS,IAAI,CAAR;AACA,QAAOA,IAAIF,QAAQG,MAAnB,EACA;AACC,MAAIH,QAAQE,CAAR,KAAc,IAAd,IAAsBF,QAAQE,CAAR,EAAWC,MAAX,GAAoB,CAA9C,EACA;AACC,UAAO;AACNR,YAASG,wBADH;AAENM,SAASJ,QAAQE,CAAR;AAFH,IAAP;AAIA;AACDA;AACA;AACD","file":"extension.js","sourcesContent":["import { VALID_DIGITS } from './constants'\n\n// The RFC 3966 format for extensions.\nconst RFC3966_EXTN_PREFIX = ';ext='\n\n// Pattern to capture digits used in an extension.\n// Places a maximum length of '7' for an extension.\nconst CAPTURING_EXTN_DIGITS = '([' + VALID_DIGITS + ']{1,7})'\n\n/**\n * Regexp of all possible ways to write extensions, for use when parsing. This\n * will be run as a case-insensitive regexp match. Wide character versions are\n * also provided after each ASCII version. There are three regular expressions\n * here. The first covers RFC 3966 format, where the extension is added using\n * ';ext='. The second more generic one starts with optional white space and\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\n * /commas and then the numbers themselves. The other one covers the special\n * case of American numbers where the extension is written with a hash at the\n * end, such as '- 503#'. Note that the only capturing groups should be around\n * the digits that you want to capture as part of the extension, or else parsing\n * will fail! We allow two options for representing the accented o - the\n * character itself, and one in the unicode decomposed form with the combining\n * acute accent.\n */\nfunction create_extension_pattern(purpose)\n{\n\t// One-character symbols that can be used to indicate an extension.\n\tlet single_extension_characters = 'x\\uFF58#\\uFF03~\\uFF5E'\n\n\tswitch (purpose)\n\t{\n\t\t// For parsing, we are slightly more lenient in our interpretation than for matching. Here we\n\t\t// allow \"comma\" and \"semicolon\" as possible extension indicators. When matching, these are\n\t\tcase 'parsing':\n\t\t\tsingle_extension_characters = ',;' + single_extension_characters\n\t}\n\n\treturn RFC3966_EXTN_PREFIX +\n\t\tCAPTURING_EXTN_DIGITS + '|' +\n\t\t'[ \\u00A0\\\\t,]*' +\n\t\t'(?:e?xt(?:ensi(?:o\\u0301?|\\u00F3))?n?|\\uFF45?\\uFF58\\uFF54\\uFF4E?|' +\n\t\t// \"доб.\"\n\t\t'\\u0434\\u043E\\u0431|' +\n\t\t'[' + single_extension_characters + ']|int|anexo|\\uFF49\\uFF4E\\uFF54)' +\n\t\t'[:\\\\.\\uFF0E]?[ \\u00A0\\\\t,-]*' +\n\t\tCAPTURING_EXTN_DIGITS + '#?|' +\n\t\t'[- ]+([' + VALID_DIGITS + ']{1,5})#'\n}\n\n/**\n * Regexp of all possible ways to write extensions, for use when parsing. This\n * will be run as a case-insensitive regexp match. Wide character versions are\n * also provided after each ASCII version. There are three regular expressions\n * here. The first covers RFC 3966 format, where the extension is added using\n * ';ext='. The second more generic one starts with optional white space and\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\n * /commas and then the numbers themselves. The other one covers the special\n * case of American numbers where the extension is written with a hash at the\n * end, such as '- 503#'. Note that the only capturing groups should be around\n * the digits that you want to capture as part of the extension, or else parsing\n * will fail! We allow two options for representing the accented o - the\n * character itself, and one in the unicode decomposed form with the combining\n * acute accent.\n */\nexport const EXTN_PATTERNS_FOR_PARSING = create_extension_pattern('parsing')\n\nexport const EXTN_PATTERNS_FOR_MATCHING = create_extension_pattern('matching')\n\n// Regexp of all known extension prefixes used by different regions followed by\n// 1 or more valid digits, for use when parsing.\nconst EXTN_PATTERN = new RegExp('(?:' + EXTN_PATTERNS_FOR_PARSING + ')$', 'i')\n\n// Strips any extension (as in, the part of the number dialled after the call is\n// connected, usually indicated with extn, ext, x or similar) from the end of\n// the number, and returns it.\nexport function extractExtension(number)\n{\n\tconst start = number.search(EXTN_PATTERN)\n\tif (start < 0) {\n\t\treturn {}\n\t}\n\n\t// If we find a potential extension, and the number preceding this is a viable\n\t// number, we assume it is an extension.\n\tconst number_without_extension = number.slice(0, start)\n\n\tconst matches = number.match(EXTN_PATTERN)\n\tlet i = 1\n\twhile (i < matches.length)\n\t{\n\t\tif (matches[i] != null && matches[i].length > 0)\n\t\t{\n\t\t\treturn {\n\t\t\t\tnumber : number_without_extension,\n\t\t\t\text    : matches[i]\n\t\t\t}\n\t\t}\n\t\ti++\n\t}\n}"]}